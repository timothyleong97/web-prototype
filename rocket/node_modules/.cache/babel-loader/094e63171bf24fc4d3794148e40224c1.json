{"ast":null,"code":"'use strict';\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar net = require('net');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util'); // eslint-disable-next-line\n\n\nconst {\n  parse,\n  serialize\n} = require('../../pg-protocol/dist'); // TODO(bmc) support binary mode here\n// var BINARY_MODE = 1\n\n\nconsole.log('***using faster connection***');\n\nvar Connection = function (config) {\n  EventEmitter.call(this);\n  config = config || {};\n  this.stream = config.stream || new net.Socket();\n  this.stream.setNoDelay(true);\n  this._keepAlive = config.keepAlive;\n  this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;\n  this.lastBuffer = false;\n  this.parsedStatements = {};\n  this.ssl = config.ssl || false;\n  this._ending = false;\n  this._emitMessage = false;\n  var self = this;\n  this.on('newListener', function (eventName) {\n    if (eventName === 'message') {\n      self._emitMessage = true;\n    }\n  });\n};\n\nutil.inherits(Connection, EventEmitter);\n\nConnection.prototype.connect = function (port, host) {\n  var self = this;\n\n  if (this.stream.readyState === 'closed') {\n    this.stream.connect(port, host);\n  } else if (this.stream.readyState === 'open') {\n    this.emit('connect');\n  }\n\n  this.stream.on('connect', function () {\n    if (self._keepAlive) {\n      self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);\n    }\n\n    self.emit('connect');\n  });\n\n  const reportStreamError = function (error) {\n    // errors about disconnections should be ignored during disconnect\n    if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n      return;\n    }\n\n    self.emit('error', error);\n  };\n\n  this.stream.on('error', reportStreamError);\n  this.stream.on('close', function () {\n    self.emit('end');\n  });\n\n  if (!this.ssl) {\n    return this.attachListeners(this.stream);\n  }\n\n  this.stream.once('data', function (buffer) {\n    var responseCode = buffer.toString('utf8');\n\n    switch (responseCode) {\n      case 'S':\n        // Server supports SSL connections, continue with a secure connection\n        break;\n\n      case 'N':\n        // Server does not support SSL connections\n        self.stream.end();\n        return self.emit('error', new Error('The server does not support SSL connections'));\n\n      default:\n        // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n        self.stream.end();\n        return self.emit('error', new Error('There was an error establishing an SSL connection'));\n    }\n\n    var tls = require('tls');\n\n    const options = Object.assign({\n      socket: self.stream\n    }, self.ssl);\n\n    if (net.isIP(host) === 0) {\n      options.servername = host;\n    }\n\n    self.stream = tls.connect(options);\n    self.attachListeners(self.stream);\n    self.stream.on('error', reportStreamError);\n    self.emit('sslconnect');\n  });\n};\n\nConnection.prototype.attachListeners = function (stream) {\n  stream.on('end', () => {\n    this.emit('end');\n  });\n  parse(stream, msg => {\n    var eventName = msg.name === 'error' ? 'errorMessage' : msg.name;\n\n    if (this._emitMessage) {\n      this.emit('message', msg);\n    }\n\n    this.emit(eventName, msg);\n  });\n};\n\nConnection.prototype.requestSsl = function () {\n  this.stream.write(serialize.requestSsl());\n};\n\nConnection.prototype.startup = function (config) {\n  this.stream.write(serialize.startup(config));\n};\n\nConnection.prototype.cancel = function (processID, secretKey) {\n  this._send(serialize.cancel(processID, secretKey));\n};\n\nConnection.prototype.password = function (password) {\n  this._send(serialize.password(password));\n};\n\nConnection.prototype.sendSASLInitialResponseMessage = function (mechanism, initialResponse) {\n  this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));\n};\n\nConnection.prototype.sendSCRAMClientFinalMessage = function (additionalData) {\n  this._send(serialize.sendSCRAMClientFinalMessage(additionalData));\n};\n\nConnection.prototype._send = function (buffer) {\n  if (!this.stream.writable) {\n    return false;\n  }\n\n  return this.stream.write(buffer);\n};\n\nConnection.prototype.query = function (text) {\n  this._send(serialize.query(text));\n}; // send parse message\n\n\nConnection.prototype.parse = function (query) {\n  this._send(serialize.parse(query));\n}; // send bind message\n// \"more\" === true to buffer the message until flush() is called\n\n\nConnection.prototype.bind = function (config) {\n  this._send(serialize.bind(config));\n}; // send execute message\n// \"more\" === true to buffer the message until flush() is called\n\n\nConnection.prototype.execute = function (config) {\n  this._send(serialize.execute(config));\n};\n\nconst flushBuffer = serialize.flush();\n\nConnection.prototype.flush = function () {\n  if (this.stream.writable) {\n    this.stream.write(flushBuffer);\n  }\n};\n\nconst syncBuffer = serialize.sync();\n\nConnection.prototype.sync = function () {\n  this._ending = true;\n\n  this._send(syncBuffer);\n\n  this._send(flushBuffer);\n};\n\nconst endBuffer = serialize.end();\n\nConnection.prototype.end = function () {\n  // 0x58 = 'X'\n  this._ending = true;\n\n  if (!this.stream.writable) {\n    this.stream.end();\n    return;\n  }\n\n  return this.stream.write(endBuffer, () => {\n    this.stream.end();\n  });\n};\n\nConnection.prototype.close = function (msg) {\n  this._send(serialize.close(msg));\n};\n\nConnection.prototype.describe = function (msg) {\n  this._send(serialize.describe(msg));\n};\n\nConnection.prototype.sendCopyFromChunk = function (chunk) {\n  this._send(serialize.copyData(chunk));\n};\n\nConnection.prototype.endCopyFrom = function () {\n  this._send(serialize.copyDone());\n};\n\nConnection.prototype.sendCopyFail = function (msg) {\n  this._send(serialize.copyFail(msg));\n};\n\nmodule.exports = Connection;","map":{"version":3,"sources":["C:/Users/User/Documents/GitHub/web-prototype/rocket/src/backend/node_modules/pg/lib/connection-fast.js"],"names":["net","require","EventEmitter","util","parse","serialize","console","log","Connection","config","call","stream","Socket","setNoDelay","_keepAlive","keepAlive","_keepAliveInitialDelayMillis","keepAliveInitialDelayMillis","lastBuffer","parsedStatements","ssl","_ending","_emitMessage","self","on","eventName","inherits","prototype","connect","port","host","readyState","emit","setKeepAlive","reportStreamError","error","code","attachListeners","once","buffer","responseCode","toString","end","Error","tls","options","Object","assign","socket","isIP","servername","msg","name","requestSsl","write","startup","cancel","processID","secretKey","_send","password","sendSASLInitialResponseMessage","mechanism","initialResponse","sendSCRAMClientFinalMessage","additionalData","writable","query","text","bind","execute","flushBuffer","flush","syncBuffer","sync","endBuffer","close","describe","sendCopyFromChunk","chunk","copyData","endCopyFrom","copyDone","sendCopyFail","copyFail","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar net = require('net')\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\n\n// eslint-disable-next-line\nconst { parse, serialize } = require('../../pg-protocol/dist')\n\n// TODO(bmc) support binary mode here\n// var BINARY_MODE = 1\nconsole.log('***using faster connection***')\nvar Connection = function (config) {\n  EventEmitter.call(this)\n  config = config || {}\n  this.stream = config.stream || new net.Socket()\n  this.stream.setNoDelay(true)\n  this._keepAlive = config.keepAlive\n  this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis\n  this.lastBuffer = false\n  this.parsedStatements = {}\n  this.ssl = config.ssl || false\n  this._ending = false\n  this._emitMessage = false\n  var self = this\n  this.on('newListener', function (eventName) {\n    if (eventName === 'message') {\n      self._emitMessage = true\n    }\n  })\n}\n\nutil.inherits(Connection, EventEmitter)\n\nConnection.prototype.connect = function (port, host) {\n  var self = this\n\n  if (this.stream.readyState === 'closed') {\n    this.stream.connect(port, host)\n  } else if (this.stream.readyState === 'open') {\n    this.emit('connect')\n  }\n\n  this.stream.on('connect', function () {\n    if (self._keepAlive) {\n      self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis)\n    }\n    self.emit('connect')\n  })\n\n  const reportStreamError = function (error) {\n    // errors about disconnections should be ignored during disconnect\n    if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n      return\n    }\n    self.emit('error', error)\n  }\n  this.stream.on('error', reportStreamError)\n\n  this.stream.on('close', function () {\n    self.emit('end')\n  })\n\n  if (!this.ssl) {\n    return this.attachListeners(this.stream)\n  }\n\n  this.stream.once('data', function (buffer) {\n    var responseCode = buffer.toString('utf8')\n    switch (responseCode) {\n      case 'S': // Server supports SSL connections, continue with a secure connection\n        break\n      case 'N': // Server does not support SSL connections\n        self.stream.end()\n        return self.emit('error', new Error('The server does not support SSL connections'))\n      default: // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n        self.stream.end()\n        return self.emit('error', new Error('There was an error establishing an SSL connection'))\n    }\n    var tls = require('tls')\n    const options = Object.assign({\n      socket: self.stream\n    }, self.ssl)\n    if (net.isIP(host) === 0) {\n      options.servername = host\n    }\n    self.stream = tls.connect(options)\n    self.attachListeners(self.stream)\n    self.stream.on('error', reportStreamError)\n\n    self.emit('sslconnect')\n  })\n}\n\nConnection.prototype.attachListeners = function (stream) {\n  stream.on('end', () => {\n    this.emit('end')\n  })\n  parse(stream, (msg) => {\n    var eventName = msg.name === 'error' ? 'errorMessage' : msg.name\n    if (this._emitMessage) {\n      this.emit('message', msg)\n    }\n    this.emit(eventName, msg)\n  })\n}\n\nConnection.prototype.requestSsl = function () {\n  this.stream.write(serialize.requestSsl())\n}\n\nConnection.prototype.startup = function (config) {\n  this.stream.write(serialize.startup(config))\n}\n\nConnection.prototype.cancel = function (processID, secretKey) {\n  this._send(serialize.cancel(processID, secretKey))\n}\n\nConnection.prototype.password = function (password) {\n  this._send(serialize.password(password))\n}\n\nConnection.prototype.sendSASLInitialResponseMessage = function (mechanism, initialResponse) {\n  this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse))\n}\n\nConnection.prototype.sendSCRAMClientFinalMessage = function (additionalData) {\n  this._send(serialize.sendSCRAMClientFinalMessage(additionalData))\n}\n\nConnection.prototype._send = function (buffer) {\n  if (!this.stream.writable) {\n    return false\n  }\n  return this.stream.write(buffer)\n}\n\nConnection.prototype.query = function (text) {\n  this._send(serialize.query(text))\n}\n\n// send parse message\nConnection.prototype.parse = function (query) {\n  this._send(serialize.parse(query))\n}\n\n// send bind message\n// \"more\" === true to buffer the message until flush() is called\nConnection.prototype.bind = function (config) {\n  this._send(serialize.bind(config))\n}\n\n// send execute message\n// \"more\" === true to buffer the message until flush() is called\nConnection.prototype.execute = function (config) {\n  this._send(serialize.execute(config))\n}\n\nconst flushBuffer = serialize.flush()\nConnection.prototype.flush = function () {\n  if (this.stream.writable) {\n    this.stream.write(flushBuffer)\n  }\n}\n\nconst syncBuffer = serialize.sync()\nConnection.prototype.sync = function () {\n  this._ending = true\n  this._send(syncBuffer)\n  this._send(flushBuffer)\n}\n\nconst endBuffer = serialize.end()\n\nConnection.prototype.end = function () {\n  // 0x58 = 'X'\n  this._ending = true\n  if (!this.stream.writable) {\n    this.stream.end()\n    return\n  }\n  return this.stream.write(endBuffer, () => {\n    this.stream.end()\n  })\n}\n\nConnection.prototype.close = function (msg) {\n  this._send(serialize.close(msg))\n}\n\nConnection.prototype.describe = function (msg) {\n  this._send(serialize.describe(msg))\n}\n\nConnection.prototype.sendCopyFromChunk = function (chunk) {\n  this._send(serialize.copyData(chunk))\n}\n\nConnection.prototype.endCopyFrom = function () {\n  this._send(serialize.copyDone())\n}\n\nConnection.prototype.sendCopyFail = function (msg) {\n  this._send(serialize.copyFail(msg))\n}\n\nmodule.exports = Connection\n"]},"metadata":{},"sourceType":"module"}