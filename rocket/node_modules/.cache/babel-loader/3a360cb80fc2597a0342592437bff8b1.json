{"ast":null,"code":"// This is our backend server. It listens to all GET/POST/DELETE requests and sends back a response.\n\n/**\r\n * 1. Route up everything so far\r\n * 2. Clean up the stock code and remake the splash\r\n * 3. Set up the database\r\n * 4. Turn app into a class\r\n * 5. Use react router for auth redirect or use redirect with a ternary\r\n */\nconst express = require(\"express\");\n\nconst client = require(\"./elephantsql\");\n\nconst app = express();\nconst port = 3500;\napp.use(express.json()); //Don't modify above this comment (other than changing the port number if you need)\n\n/** Steps to create an API endpoint\r\n *\r\n * 1. Decide if you want to listen for a POST/GET/DELETE/PATCH request\r\n * 2. Decide on a suitable and unused url path\r\n * 3. Put in the comments above the endpoint - what information do you want to receive in req.body?\r\n *    If the frontend sends in a js object, write down the name of each key and the data type of each\r\n *    value in the comments so that whoever looks at the frontend can figure out if a negative response from the db is\r\n *    simply due to wrong formatting of data\r\n * 4. Write down what you intend to do before you send something back to the frontend\r\n *    - e.g send a specific type of SQL query to the DB\r\n * 5. Write down what you want to send back - always send some feedback to the frontend that allows the frontend\r\n *    to tell the user that the action was completed successfully or that it failed.\r\n * 6. write app.< what you chose in step 1 >('your/path', (req, res) => {\r\n *        //note that req is an object containing meta info about the request, what you want is req.body\r\n *        //which contains the js object sent from frontend\r\n *        //res is an object that allows you to send things back to the user via res.send(text/json)\r\n *\r\n *        // what you wanted to read from user in step 3\r\n *\r\n *        // what you wanted to do in the db in step 4\r\n *\r\n *        // what you wanted to send back to the user in step 5\r\n *    })\r\n *\r\n * 7. As far as possible, group endpoints that are for the same React component together for easy debugging, e.g.\r\n *     //  -- Signup --\r\n *     app.post('/signup', ...)\r\n *     // -- Login --\r\n *     app.post('/login', ...)\r\n * 8. Don't forget step 3\r\n * API for client at https://node-postgres.com/api/client\r\n * API for pgadmin setup at https://www.elephantsql.com/docs/pgadmin.html\r\n */\n//  --  Signup  --\n\n/** req.body should be {\r\n        firstName: String,\r\n        lastName: String,\r\n        username: String,\r\n        credit_card: String,\r\n        password: String     \r\n     } \r\n\r\n     Frontend should make sure all fields are present before sending to backend.\r\n\r\n     Concatenate firstName and lastName with a whitespace in between for the attribute customer_name in Customers\r\n     Initialise reward points as 0, start date as CURRENT_DATE (a reserved keyword in PGSQL referring to current date)\r\n     \r\n     Send an insert statement to the database with the above variables\r\n\r\n     What will be returned from the database is a Result object that looks like this (in the then function call of the Promise):  \r\n            Result {\r\n              command: 'INSERT',\r\n              rowCount: 1,\r\n              oid: 0,\r\n              rows: [],\r\n              fields: [],\r\n              _parsers: undefined,\r\n              _types: TypeOverrides {\r\n                _types: {\r\n                  getTypeParser: [Function: getTypeParser],\r\n                  setTypeParser: [Function: setTypeParser],\r\n                  arrayParser: [Object],\r\n                  builtins: [Object]\r\n                },\r\n                text: {},\r\n                binary: {}\r\n              },\r\n              RowCtor: null,\r\n              rowAsArray: false\r\n            }\r\n      If there is an error (which will cause the catch function call to run instead), an error message is returned instead. So if in the then call,\r\n      send a js object back to the frontend like: {\r\n         status: 400\r\n         message: error.detail\r\n      } else send {\r\n         status: 200\r\n      }\r\n      so that the frontend can then either prompt the user to check and resubmit, or redirect the user straight to the catalogue page.\r\n      Note: use Postman to send in a post request during testing\r\n */\n\napp.post(\"/signup\", (req, res) => {\n  let {\n    firstName,\n    lastName,\n    username,\n    credit_card,\n    password\n  } = req.body;\n  const customername = firstName + \" \" + lastName; //First insert this person into Users\n\n  client.query(`INSERT INTO users(userid,user_password)\n     VALUES($1,$2);`, [username, password]).then( //Next insert this person into Customers\n  _ => client.query(`INSERT INTO customers(cid,customer_name,reward_points,join_date,credit_card)\n           VALUES($1,$2, 0, CURRENT_DATE, $3);`, [username, customername, credit_card]).then(_ => {\n    res.send({\n      status: 200\n    }); //OK\n  }).catch(error => {\n    res.send({\n      status: 400,\n      message: error.detail\n    }); //BAD REQUEST\n  })).catch(error => {\n    console.log(error);\n    res.send({\n      status: 400,\n      message: error.detail // \"Key (userid)=(timothyleong) already exists.\"\n\n    });\n  });\n}); // --LOGIN--\n\n/** req.body should be {\r\n        username: String,\r\n        password: String     \r\n     } \r\n\r\n     Frontend should make sure all fields are present before sending to backend.\r\n\r\n     Send an insert statement to the database with the above variables\r\n\r\n     If there is an error (which will cause the catch function call to run instead), an error message is returned instead. So if in the then call,\r\n      send a js object back to the frontend: {\r\n         status: 400\r\n         message: error.detail\r\n      } else send {\r\n         status: 200\r\n      }\r\n      so that the frontend can then either prompt the user to check and resubmit, or redirect the user straight to the catalogue page.\r\n\r\n      Note that this signin is for customer - i.e we check only the Customer table to see if the user exists as a Customer. There should be other endpoints for authenticating the other kinds of users\r\n */\n\napp.post(\"/signin/customer\", (req, res) => {\n  let {\n    username,\n    password\n  } = req.body;\n  client.query(`SELECT * \n                FROM users \n                WHERE userid = $1\n                AND user_password = $2`, [username, password]).then(result => {\n    if (result.rowCount == 0) {\n      //such a record does not exist\n      res.send({\n        status: 401\n      }); //UNAUTHORISED\n    } else {\n      res.send({\n        status: 200,\n        user: 'CUSTOMER' // Let frontend know what to display \n\n      }); // OK\n    }\n  }).catch(_ => res.send({\n    status: 500 //SERVER ERROR\n\n  }));\n}); //Don't modify below this comment\n\napp.listen(port, () => {\n  console.log(\"Backend server is up on port \" + port);\n});\nexport { port }; // so that our axios client in the frontend automatically knows where to send requests to","map":{"version":3,"sources":["C:/Users/User/Documents/GitHub/web-prototype/rocket/src/backend/app.js"],"names":["express","require","client","app","port","use","json","post","req","res","firstName","lastName","username","credit_card","password","body","customername","query","then","_","send","status","catch","error","message","detail","console","log","result","rowCount","user","listen"],"mappings":"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","sourcesContent":["// This is our backend server. It listens to all GET/POST/DELETE requests and sends back a response.\r\n/**\r\n * 1. Route up everything so far\r\n * 2. Clean up the stock code and remake the splash\r\n * 3. Set up the database\r\n * 4. Turn app into a class\r\n * 5. Use react router for auth redirect or use redirect with a ternary\r\n */\r\n\r\nconst express = require(\"express\");\r\nconst client = require(\"./elephantsql\");\r\n\r\nconst app = express();\r\nconst port = 3500;\r\n\r\napp.use(express.json());\r\n//Don't modify above this comment (other than changing the port number if you need)\r\n\r\n/** Steps to create an API endpoint\r\n *\r\n * 1. Decide if you want to listen for a POST/GET/DELETE/PATCH request\r\n * 2. Decide on a suitable and unused url path\r\n * 3. Put in the comments above the endpoint - what information do you want to receive in req.body?\r\n *    If the frontend sends in a js object, write down the name of each key and the data type of each\r\n *    value in the comments so that whoever looks at the frontend can figure out if a negative response from the db is\r\n *    simply due to wrong formatting of data\r\n * 4. Write down what you intend to do before you send something back to the frontend\r\n *    - e.g send a specific type of SQL query to the DB\r\n * 5. Write down what you want to send back - always send some feedback to the frontend that allows the frontend\r\n *    to tell the user that the action was completed successfully or that it failed.\r\n * 6. write app.< what you chose in step 1 >('your/path', (req, res) => {\r\n *        //note that req is an object containing meta info about the request, what you want is req.body\r\n *        //which contains the js object sent from frontend\r\n *        //res is an object that allows you to send things back to the user via res.send(text/json)\r\n *\r\n *        // what you wanted to read from user in step 3\r\n *\r\n *        // what you wanted to do in the db in step 4\r\n *\r\n *        // what you wanted to send back to the user in step 5\r\n *    })\r\n *\r\n * 7. As far as possible, group endpoints that are for the same React component together for easy debugging, e.g.\r\n *     //  -- Signup --\r\n *     app.post('/signup', ...)\r\n *     // -- Login --\r\n *     app.post('/login', ...)\r\n * 8. Don't forget step 3\r\n * API for client at https://node-postgres.com/api/client\r\n * API for pgadmin setup at https://www.elephantsql.com/docs/pgadmin.html\r\n */\r\n\r\n//  --  Signup  --\r\n\r\n/** req.body should be {\r\n        firstName: String,\r\n        lastName: String,\r\n        username: String,\r\n        credit_card: String,\r\n        password: String     \r\n     } \r\n\r\n     Frontend should make sure all fields are present before sending to backend.\r\n\r\n     Concatenate firstName and lastName with a whitespace in between for the attribute customer_name in Customers\r\n     Initialise reward points as 0, start date as CURRENT_DATE (a reserved keyword in PGSQL referring to current date)\r\n     \r\n     Send an insert statement to the database with the above variables\r\n\r\n     What will be returned from the database is a Result object that looks like this (in the then function call of the Promise):  \r\n            Result {\r\n              command: 'INSERT',\r\n              rowCount: 1,\r\n              oid: 0,\r\n              rows: [],\r\n              fields: [],\r\n              _parsers: undefined,\r\n              _types: TypeOverrides {\r\n                _types: {\r\n                  getTypeParser: [Function: getTypeParser],\r\n                  setTypeParser: [Function: setTypeParser],\r\n                  arrayParser: [Object],\r\n                  builtins: [Object]\r\n                },\r\n                text: {},\r\n                binary: {}\r\n              },\r\n              RowCtor: null,\r\n              rowAsArray: false\r\n            }\r\n      If there is an error (which will cause the catch function call to run instead), an error message is returned instead. So if in the then call,\r\n      send a js object back to the frontend like: {\r\n         status: 400\r\n         message: error.detail\r\n      } else send {\r\n         status: 200\r\n      }\r\n      so that the frontend can then either prompt the user to check and resubmit, or redirect the user straight to the catalogue page.\r\n      Note: use Postman to send in a post request during testing\r\n */\r\napp.post(\"/signup\", (req, res) => {\r\n  let { firstName, lastName, username, credit_card, password } = req.body;\r\n  const customername = firstName + \" \" + lastName;\r\n  //First insert this person into Users\r\n  client\r\n    .query(\r\n      `INSERT INTO users(userid,user_password)\r\n     VALUES($1,$2);`,\r\n      [username, password]\r\n    )\r\n    .then(\r\n      //Next insert this person into Customers\r\n      _ => client\r\n        .query(\r\n          `INSERT INTO customers(cid,customer_name,reward_points,join_date,credit_card)\r\n           VALUES($1,$2, 0, CURRENT_DATE, $3);`,\r\n          [username, customername, credit_card]\r\n        )\r\n        .then( _ => {\r\n          res.send({ status: 200 }); //OK\r\n        })\r\n        .catch(error => {\r\n          res.send({ \r\n            status: 400,\r\n            message: error.detail\r\n          }); //BAD REQUEST\r\n        })\r\n    )\r\n    .catch(error => {\r\n      console.log(error);\r\n      res.send({\r\n        status: 400,\r\n        message: error.detail // \"Key (userid)=(timothyleong) already exists.\"\r\n      });       \r\n    });\r\n});\r\n\r\n\r\n// --LOGIN--\r\n/** req.body should be {\r\n        username: String,\r\n        password: String     \r\n     } \r\n\r\n     Frontend should make sure all fields are present before sending to backend.\r\n\r\n     Send an insert statement to the database with the above variables\r\n\r\n     If there is an error (which will cause the catch function call to run instead), an error message is returned instead. So if in the then call,\r\n      send a js object back to the frontend: {\r\n         status: 400\r\n         message: error.detail\r\n      } else send {\r\n         status: 200\r\n      }\r\n      so that the frontend can then either prompt the user to check and resubmit, or redirect the user straight to the catalogue page.\r\n\r\n      Note that this signin is for customer - i.e we check only the Customer table to see if the user exists as a Customer. There should be other endpoints for authenticating the other kinds of users\r\n */\r\napp.post(\"/signin/customer\", (req, res)=> {\r\n  let {username, password} = req.body;\r\n  client.query(`SELECT * \r\n                FROM users \r\n                WHERE userid = $1\r\n                AND user_password = $2`,\r\n                [username, password]\r\n  ).then(result => {\r\n    if (result.rowCount == 0) {\r\n      //such a record does not exist\r\n      res.send({status: 401}) //UNAUTHORISED\r\n    } else {\r\n      res.send({\r\n        status: 200,\r\n        user: 'CUSTOMER' // Let frontend know what to display \r\n      }) // OK\r\n    }\r\n  })\r\n  .catch(_ => res.send(\r\n    {\r\n      status: 500 //SERVER ERROR\r\n    }\r\n  )); \r\n})\r\n\r\n\r\n\r\n//Don't modify below this comment\r\napp.listen(port, () => {\r\n  console.log(\"Backend server is up on port \" + port);\r\n});\r\n\r\nexport {port} // so that our axios client in the frontend automatically knows where to send requests to "]},"metadata":{},"sourceType":"module"}