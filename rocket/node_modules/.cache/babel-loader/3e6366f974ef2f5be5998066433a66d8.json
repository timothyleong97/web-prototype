{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst messages_1 = require(\"./messages\");\n\nconst buffer_reader_1 = require(\"./buffer-reader\");\n\nconst assert_1 = __importDefault(require(\"assert\")); // every message is prefixed with a single bye\n\n\nconst CODE_LENGTH = 1; // every message has an int32 length which includes itself but does\n// NOT include the code in the length\n\nconst LEN_LENGTH = 4;\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nconst emptyBuffer = Buffer.allocUnsafe(0);\n\nclass Parser {\n  constructor(opts) {\n    var _a, _b;\n\n    this.remainingBuffer = emptyBuffer;\n    this.reader = new buffer_reader_1.BufferReader();\n\n    if (((_a = opts) === null || _a === void 0 ? void 0 : _a.mode) === 'binary') {\n      throw new Error('Binary mode not supported yet');\n    }\n\n    this.mode = ((_b = opts) === null || _b === void 0 ? void 0 : _b.mode) || 'text';\n  }\n\n  parse(buffer, callback) {\n    let combinedBuffer = buffer;\n\n    if (this.remainingBuffer.byteLength) {\n      combinedBuffer = Buffer.allocUnsafe(this.remainingBuffer.byteLength + buffer.byteLength);\n      this.remainingBuffer.copy(combinedBuffer);\n      buffer.copy(combinedBuffer, this.remainingBuffer.byteLength);\n    }\n\n    let offset = 0;\n\n    while (offset + HEADER_LENGTH <= combinedBuffer.byteLength) {\n      // code is 1 byte long - it identifies the message type\n      const code = combinedBuffer[offset]; // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n\n      const length = combinedBuffer.readUInt32BE(offset + CODE_LENGTH);\n      const fullMessageLength = CODE_LENGTH + length;\n\n      if (fullMessageLength + offset <= combinedBuffer.byteLength) {\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, combinedBuffer);\n        callback(message);\n        offset += fullMessageLength;\n      } else {\n        break;\n      }\n    }\n\n    if (offset === combinedBuffer.byteLength) {\n      this.remainingBuffer = emptyBuffer;\n    } else {\n      this.remainingBuffer = combinedBuffer.slice(offset);\n    }\n  }\n\n  handlePacket(offset, code, length, bytes) {\n    switch (code) {\n      case 50\n      /* BindComplete */\n      :\n        return messages_1.bindComplete;\n\n      case 49\n      /* ParseComplete */\n      :\n        return messages_1.parseComplete;\n\n      case 51\n      /* CloseComplete */\n      :\n        return messages_1.closeComplete;\n\n      case 110\n      /* NoData */\n      :\n        return messages_1.noData;\n\n      case 115\n      /* PortalSuspended */\n      :\n        return messages_1.portalSuspended;\n\n      case 99\n      /* CopyDone */\n      :\n        return messages_1.copyDone;\n\n      case 87\n      /* ReplicationStart */\n      :\n        return messages_1.replicationStart;\n\n      case 73\n      /* EmptyQuery */\n      :\n        return messages_1.emptyQuery;\n\n      case 68\n      /* DataRow */\n      :\n        return this.parseDataRowMessage(offset, length, bytes);\n\n      case 67\n      /* CommandComplete */\n      :\n        return this.parseCommandCompleteMessage(offset, length, bytes);\n\n      case 90\n      /* ReadyForQuery */\n      :\n        return this.parseReadyForQueryMessage(offset, length, bytes);\n\n      case 65\n      /* NotificationResponse */\n      :\n        return this.parseNotificationMessage(offset, length, bytes);\n\n      case 82\n      /* AuthenticationResponse */\n      :\n        return this.parseAuthenticationResponse(offset, length, bytes);\n\n      case 83\n      /* ParameterStatus */\n      :\n        return this.parseParameterStatusMessage(offset, length, bytes);\n\n      case 75\n      /* BackendKeyData */\n      :\n        return this.parseBackendKeyData(offset, length, bytes);\n\n      case 69\n      /* ErrorMessage */\n      :\n        return this.parseErrorMessage(offset, length, bytes, \"error\"\n        /* error */\n        );\n\n      case 78\n      /* NoticeMessage */\n      :\n        return this.parseErrorMessage(offset, length, bytes, \"notice\"\n        /* notice */\n        );\n\n      case 84\n      /* RowDescriptionMessage */\n      :\n        return this.parseRowDescriptionMessage(offset, length, bytes);\n\n      case 71\n      /* CopyIn */\n      :\n        return this.parseCopyInMessage(offset, length, bytes);\n\n      case 72\n      /* CopyOut */\n      :\n        return this.parseCopyOutMessage(offset, length, bytes);\n\n      case 100\n      /* CopyData */\n      :\n        return this.parseCopyData(offset, length, bytes);\n\n      default:\n        assert_1.default.fail(`unknown message code: ${code.toString(16)}`);\n    }\n  }\n\n  parseReadyForQueryMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const status = this.reader.string(1);\n    return new messages_1.ReadyForQueryMessage(length, status);\n  }\n\n  parseCommandCompleteMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const text = this.reader.cstring();\n    return new messages_1.CommandCompleteMessage(length, text);\n  }\n\n  parseCopyData(offset, length, bytes) {\n    const chunk = bytes.slice(offset, offset + (length - 4));\n    return new messages_1.CopyDataMessage(length, chunk);\n  }\n\n  parseCopyInMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, \"copyInResponse\"\n    /* copyInResponse */\n    );\n  }\n\n  parseCopyOutMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, \"copyOutResponse\"\n    /* copyOutResponse */\n    );\n  }\n\n  parseCopyMessage(offset, length, bytes, messageName) {\n    this.reader.setBuffer(offset, bytes);\n    const isBinary = this.reader.byte() !== 0;\n    const columnCount = this.reader.int16();\n    const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n\n    for (let i = 0; i < columnCount; i++) {\n      message.columnTypes[i] = this.reader.int16();\n    }\n\n    return message;\n  }\n\n  parseNotificationMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processId = this.reader.int32();\n    const channel = this.reader.cstring();\n    const payload = this.reader.cstring();\n    return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n  }\n\n  parseRowDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const message = new messages_1.RowDescriptionMessage(length, fieldCount);\n\n    for (let i = 0; i < fieldCount; i++) {\n      message.fields[i] = this.parseField();\n    }\n\n    return message;\n  }\n\n  parseField() {\n    const name = this.reader.cstring();\n    const tableID = this.reader.int32();\n    const columnID = this.reader.int16();\n    const dataTypeID = this.reader.int32();\n    const dataTypeSize = this.reader.int16();\n    const dataTypeModifier = this.reader.int32();\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary';\n    return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n  }\n\n  parseDataRowMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const fields = new Array(fieldCount);\n\n    for (let i = 0; i < fieldCount; i++) {\n      const len = this.reader.int32(); // a -1 for length means the value of the field is null\n\n      fields[i] = len === -1 ? null : this.reader.string(len);\n    }\n\n    return new messages_1.DataRowMessage(length, fields);\n  }\n\n  parseParameterStatusMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const name = this.reader.cstring();\n    const value = this.reader.cstring();\n    return new messages_1.ParameterStatusMessage(length, name, value);\n  }\n\n  parseBackendKeyData(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processID = this.reader.int32();\n    const secretKey = this.reader.int32();\n    return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n  }\n\n  parseAuthenticationResponse(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const code = this.reader.int32(); // TODO(bmc): maybe better types here\n\n    const message = {\n      name: \"authenticationOk\"\n      /* authenticationOk */\n      ,\n      length\n    };\n\n    switch (code) {\n      case 0:\n        // AuthenticationOk\n        break;\n\n      case 3:\n        // AuthenticationCleartextPassword\n        if (message.length === 8) {\n          message.name = \"authenticationCleartextPassword\"\n          /* authenticationCleartextPassword */\n          ;\n        }\n\n        break;\n\n      case 5:\n        // AuthenticationMD5Password\n        if (message.length === 12) {\n          message.name = \"authenticationMD5Password\"\n          /* authenticationMD5Password */\n          ;\n          const salt = this.reader.bytes(4);\n          return new messages_1.AuthenticationMD5Password(length, salt);\n        }\n\n        break;\n\n      case 10:\n        // AuthenticationSASL\n        message.name = \"authenticationSASL\"\n        /* authenticationSASL */\n        ;\n        message.mechanisms = [];\n        let mechanism;\n\n        do {\n          mechanism = this.reader.cstring();\n\n          if (mechanism) {\n            message.mechanisms.push(mechanism);\n          }\n        } while (mechanism);\n\n        break;\n\n      case 11:\n        // AuthenticationSASLContinue\n        message.name = \"authenticationSASLContinue\"\n        /* authenticationSASLContinue */\n        ;\n        message.data = this.reader.string(length - 4);\n        break;\n\n      case 12:\n        // AuthenticationSASLFinal\n        message.name = \"authenticationSASLFinal\"\n        /* authenticationSASLFinal */\n        ;\n        message.data = this.reader.string(length - 4);\n        break;\n\n      default:\n        throw new Error('Unknown authenticationOk message type ' + code);\n    }\n\n    return message;\n  }\n\n  parseErrorMessage(offset, length, bytes, name) {\n    this.reader.setBuffer(offset, bytes);\n    const fields = {};\n    let fieldType = this.reader.string(1);\n\n    while (fieldType !== '\\0') {\n      fields[fieldType] = this.reader.cstring();\n      fieldType = this.reader.string(1);\n    }\n\n    const messageValue = fields.M;\n    const message = name === \"notice\"\n    /* notice */\n    ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n    message.severity = fields.S;\n    message.code = fields.C;\n    message.detail = fields.D;\n    message.hint = fields.H;\n    message.position = fields.P;\n    message.internalPosition = fields.p;\n    message.internalQuery = fields.q;\n    message.where = fields.W;\n    message.schema = fields.s;\n    message.table = fields.t;\n    message.column = fields.c;\n    message.dataType = fields.d;\n    message.constraint = fields.n;\n    message.file = fields.F;\n    message.line = fields.L;\n    message.routine = fields.R;\n    return message;\n  }\n\n}\n\nexports.Parser = Parser;","map":{"version":3,"sources":["../src/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst messages_1 = require(\"./messages\");\nconst buffer_reader_1 = require(\"./buffer-reader\");\nconst assert_1 = __importDefault(require(\"assert\"));\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1;\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4;\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nconst emptyBuffer = Buffer.allocUnsafe(0);\nclass Parser {\n    constructor(opts) {\n        var _a, _b;\n        this.remainingBuffer = emptyBuffer;\n        this.reader = new buffer_reader_1.BufferReader();\n        if (((_a = opts) === null || _a === void 0 ? void 0 : _a.mode) === 'binary') {\n            throw new Error('Binary mode not supported yet');\n        }\n        this.mode = ((_b = opts) === null || _b === void 0 ? void 0 : _b.mode) || 'text';\n    }\n    parse(buffer, callback) {\n        let combinedBuffer = buffer;\n        if (this.remainingBuffer.byteLength) {\n            combinedBuffer = Buffer.allocUnsafe(this.remainingBuffer.byteLength + buffer.byteLength);\n            this.remainingBuffer.copy(combinedBuffer);\n            buffer.copy(combinedBuffer, this.remainingBuffer.byteLength);\n        }\n        let offset = 0;\n        while ((offset + HEADER_LENGTH) <= combinedBuffer.byteLength) {\n            // code is 1 byte long - it identifies the message type\n            const code = combinedBuffer[offset];\n            // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n            const length = combinedBuffer.readUInt32BE(offset + CODE_LENGTH);\n            const fullMessageLength = CODE_LENGTH + length;\n            if (fullMessageLength + offset <= combinedBuffer.byteLength) {\n                const message = this.handlePacket(offset + HEADER_LENGTH, code, length, combinedBuffer);\n                callback(message);\n                offset += fullMessageLength;\n            }\n            else {\n                break;\n            }\n        }\n        if (offset === combinedBuffer.byteLength) {\n            this.remainingBuffer = emptyBuffer;\n        }\n        else {\n            this.remainingBuffer = combinedBuffer.slice(offset);\n        }\n    }\n    handlePacket(offset, code, length, bytes) {\n        switch (code) {\n            case 50 /* BindComplete */:\n                return messages_1.bindComplete;\n            case 49 /* ParseComplete */:\n                return messages_1.parseComplete;\n            case 51 /* CloseComplete */:\n                return messages_1.closeComplete;\n            case 110 /* NoData */:\n                return messages_1.noData;\n            case 115 /* PortalSuspended */:\n                return messages_1.portalSuspended;\n            case 99 /* CopyDone */:\n                return messages_1.copyDone;\n            case 87 /* ReplicationStart */:\n                return messages_1.replicationStart;\n            case 73 /* EmptyQuery */:\n                return messages_1.emptyQuery;\n            case 68 /* DataRow */:\n                return this.parseDataRowMessage(offset, length, bytes);\n            case 67 /* CommandComplete */:\n                return this.parseCommandCompleteMessage(offset, length, bytes);\n            case 90 /* ReadyForQuery */:\n                return this.parseReadyForQueryMessage(offset, length, bytes);\n            case 65 /* NotificationResponse */:\n                return this.parseNotificationMessage(offset, length, bytes);\n            case 82 /* AuthenticationResponse */:\n                return this.parseAuthenticationResponse(offset, length, bytes);\n            case 83 /* ParameterStatus */:\n                return this.parseParameterStatusMessage(offset, length, bytes);\n            case 75 /* BackendKeyData */:\n                return this.parseBackendKeyData(offset, length, bytes);\n            case 69 /* ErrorMessage */:\n                return this.parseErrorMessage(offset, length, bytes, \"error\" /* error */);\n            case 78 /* NoticeMessage */:\n                return this.parseErrorMessage(offset, length, bytes, \"notice\" /* notice */);\n            case 84 /* RowDescriptionMessage */:\n                return this.parseRowDescriptionMessage(offset, length, bytes);\n            case 71 /* CopyIn */:\n                return this.parseCopyInMessage(offset, length, bytes);\n            case 72 /* CopyOut */:\n                return this.parseCopyOutMessage(offset, length, bytes);\n            case 100 /* CopyData */:\n                return this.parseCopyData(offset, length, bytes);\n            default:\n                assert_1.default.fail(`unknown message code: ${code.toString(16)}`);\n        }\n    }\n    parseReadyForQueryMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const status = this.reader.string(1);\n        return new messages_1.ReadyForQueryMessage(length, status);\n    }\n    parseCommandCompleteMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const text = this.reader.cstring();\n        return new messages_1.CommandCompleteMessage(length, text);\n    }\n    parseCopyData(offset, length, bytes) {\n        const chunk = bytes.slice(offset, offset + (length - 4));\n        return new messages_1.CopyDataMessage(length, chunk);\n    }\n    parseCopyInMessage(offset, length, bytes) {\n        return this.parseCopyMessage(offset, length, bytes, \"copyInResponse\" /* copyInResponse */);\n    }\n    parseCopyOutMessage(offset, length, bytes) {\n        return this.parseCopyMessage(offset, length, bytes, \"copyOutResponse\" /* copyOutResponse */);\n    }\n    parseCopyMessage(offset, length, bytes, messageName) {\n        this.reader.setBuffer(offset, bytes);\n        const isBinary = this.reader.byte() !== 0;\n        const columnCount = this.reader.int16();\n        const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n        for (let i = 0; i < columnCount; i++) {\n            message.columnTypes[i] = this.reader.int16();\n        }\n        return message;\n    }\n    parseNotificationMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const processId = this.reader.int32();\n        const channel = this.reader.cstring();\n        const payload = this.reader.cstring();\n        return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n    }\n    parseRowDescriptionMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const fieldCount = this.reader.int16();\n        const message = new messages_1.RowDescriptionMessage(length, fieldCount);\n        for (let i = 0; i < fieldCount; i++) {\n            message.fields[i] = this.parseField();\n        }\n        return message;\n    }\n    parseField() {\n        const name = this.reader.cstring();\n        const tableID = this.reader.int32();\n        const columnID = this.reader.int16();\n        const dataTypeID = this.reader.int32();\n        const dataTypeSize = this.reader.int16();\n        const dataTypeModifier = this.reader.int32();\n        const mode = this.reader.int16() === 0 ? 'text' : 'binary';\n        return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n    }\n    parseDataRowMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const fieldCount = this.reader.int16();\n        const fields = new Array(fieldCount);\n        for (let i = 0; i < fieldCount; i++) {\n            const len = this.reader.int32();\n            // a -1 for length means the value of the field is null\n            fields[i] = len === -1 ? null : this.reader.string(len);\n        }\n        return new messages_1.DataRowMessage(length, fields);\n    }\n    parseParameterStatusMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const name = this.reader.cstring();\n        const value = this.reader.cstring();\n        return new messages_1.ParameterStatusMessage(length, name, value);\n    }\n    parseBackendKeyData(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const processID = this.reader.int32();\n        const secretKey = this.reader.int32();\n        return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n    }\n    parseAuthenticationResponse(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const code = this.reader.int32();\n        // TODO(bmc): maybe better types here\n        const message = {\n            name: \"authenticationOk\" /* authenticationOk */,\n            length,\n        };\n        switch (code) {\n            case 0: // AuthenticationOk\n                break;\n            case 3: // AuthenticationCleartextPassword\n                if (message.length === 8) {\n                    message.name = \"authenticationCleartextPassword\" /* authenticationCleartextPassword */;\n                }\n                break;\n            case 5: // AuthenticationMD5Password\n                if (message.length === 12) {\n                    message.name = \"authenticationMD5Password\" /* authenticationMD5Password */;\n                    const salt = this.reader.bytes(4);\n                    return new messages_1.AuthenticationMD5Password(length, salt);\n                }\n                break;\n            case 10: // AuthenticationSASL\n                message.name = \"authenticationSASL\" /* authenticationSASL */;\n                message.mechanisms = [];\n                let mechanism;\n                do {\n                    mechanism = this.reader.cstring();\n                    if (mechanism) {\n                        message.mechanisms.push(mechanism);\n                    }\n                } while (mechanism);\n                break;\n            case 11: // AuthenticationSASLContinue\n                message.name = \"authenticationSASLContinue\" /* authenticationSASLContinue */;\n                message.data = this.reader.string(length - 4);\n                break;\n            case 12: // AuthenticationSASLFinal\n                message.name = \"authenticationSASLFinal\" /* authenticationSASLFinal */;\n                message.data = this.reader.string(length - 4);\n                break;\n            default:\n                throw new Error('Unknown authenticationOk message type ' + code);\n        }\n        return message;\n    }\n    parseErrorMessage(offset, length, bytes, name) {\n        this.reader.setBuffer(offset, bytes);\n        const fields = {};\n        let fieldType = this.reader.string(1);\n        while (fieldType !== '\\0') {\n            fields[fieldType] = this.reader.cstring();\n            fieldType = this.reader.string(1);\n        }\n        const messageValue = fields.M;\n        const message = name === \"notice\" /* notice */ ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n        message.severity = fields.S;\n        message.code = fields.C;\n        message.detail = fields.D;\n        message.hint = fields.H;\n        message.position = fields.P;\n        message.internalPosition = fields.p;\n        message.internalQuery = fields.q;\n        message.where = fields.W;\n        message.schema = fields.s;\n        message.table = fields.t;\n        message.column = fields.c;\n        message.dataType = fields.d;\n        message.constraint = fields.n;\n        message.file = fields.F;\n        message.line = fields.L;\n        message.routine = fields.R;\n        return message;\n    }\n}\nexports.Parser = Parser;\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"module"}