{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst NOOP = function () {};\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate);\n  return i === -1 ? undefined : list.splice(i, 1)[0];\n};\n\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client;\n    this.idleListener = idleListener;\n    this.timeoutId = timeoutId;\n  }\n\n}\n\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback;\n  }\n\n}\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.');\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return {\n      callback: callback,\n      result: undefined\n    };\n  }\n\n  let rej;\n  let res;\n\n  const cb = function (err, client) {\n    err ? rej(err) : res(client);\n  };\n\n  const result = new Promise(function (resolve, reject) {\n    res = resolve;\n    rej = reject;\n  });\n  return {\n    callback: cb,\n    result: result\n  };\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client;\n    client.removeListener('error', idleListener);\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err);\n    });\n\n    pool._remove(client); // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n\n\n    pool.emit('error', err, client);\n  };\n}\n\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super();\n    this.options = Object.assign({}, options);\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password\n      });\n    }\n\n    this.options.max = this.options.max || this.options.poolSize || 10;\n    this.options.maxUses = this.options.maxUses || Infinity;\n\n    this.log = this.options.log || function () {};\n\n    this.Client = this.options.Client || Client || require('pg').Client;\n    this.Promise = this.options.Promise || global.Promise;\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000;\n    }\n\n    this._clients = [];\n    this._idle = [];\n    this._pendingQueue = [];\n    this._endCallback = undefined;\n    this.ending = false;\n    this.ended = false;\n  }\n\n  _isFull() {\n    return this._clients.length >= this.options.max;\n  }\n\n  _pulseQueue() {\n    this.log('pulse queue');\n\n    if (this.ended) {\n      this.log('pulse queue ended');\n      return;\n    }\n\n    if (this.ending) {\n      this.log('pulse queue on ending');\n\n      if (this._idle.length) {\n        this._idle.slice().map(item => {\n          this._remove(item.client);\n        });\n      }\n\n      if (!this._clients.length) {\n        this.ended = true;\n\n        this._endCallback();\n      }\n\n      return;\n    } // if we don't have any waiting, do nothing\n\n\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests');\n      return;\n    } // if we don't have any idle clients and we have no more room do nothing\n\n\n    if (!this._idle.length && this._isFull()) {\n      return;\n    }\n\n    const pendingItem = this._pendingQueue.shift();\n\n    if (this._idle.length) {\n      const idleItem = this._idle.pop();\n\n      clearTimeout(idleItem.timeoutId);\n      const client = idleItem.client;\n      const idleListener = idleItem.idleListener;\n      return this._acquireClient(client, pendingItem, idleListener, false);\n    }\n\n    if (!this._isFull()) {\n      return this.newClient(pendingItem);\n    }\n\n    throw new Error('unexpected condition');\n  }\n\n  _remove(client) {\n    const removed = removeWhere(this._idle, item => item.client === client);\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId);\n    }\n\n    this._clients = this._clients.filter(c => c !== client);\n    client.end();\n    this.emit('remove', client);\n  }\n\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool');\n      return cb ? cb(err) : this.Promise.reject(err);\n    }\n\n    const response = promisify(this.Promise, cb);\n    const result = response.result; // if we don't have to connect a new client, don't do so\n\n    if (this._clients.length >= this.options.max || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue());\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback));\n\n        return result;\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid);\n        response.callback(err, res, done);\n      };\n\n      const pendingItem = new PendingItem(queueCallback); // set connection timeout on checking out an existing client\n\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, i => i.callback === queueCallback);\n        pendingItem.timedOut = true;\n        response.callback(new Error('timeout exceeded when trying to connect'));\n      }, this.options.connectionTimeoutMillis);\n\n      this._pendingQueue.push(pendingItem);\n\n      return result;\n    }\n\n    this.newClient(new PendingItem(response.callback));\n    return result;\n  }\n\n  newClient(pendingItem) {\n    const client = new this.Client(this.options);\n\n    this._clients.push(client);\n\n    const idleListener = makeIdleListener(this, client);\n    this.log('checking client timeout'); // connection timeout logic\n\n    let tid;\n    let timeoutHit = false;\n\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout');\n        timeoutHit = true; // force kill the node driver, and let libpq do its teardown\n\n        client.connection ? client.connection.stream.destroy() : client.end();\n      }, this.options.connectionTimeoutMillis);\n    }\n\n    this.log('connecting new client');\n    client.connect(err => {\n      if (tid) {\n        clearTimeout(tid);\n      }\n\n      client.on('error', idleListener);\n\n      if (err) {\n        this.log('client failed to connect', err); // remove the dead client from our list of clients\n\n        this._clients = this._clients.filter(c => c !== client);\n\n        if (timeoutHit) {\n          err.message = 'Connection terminated due to connection timeout';\n        } // this client wonâ€™t be released, so move on immediately\n\n\n        this._pulseQueue();\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP);\n        }\n      } else {\n        this.log('new client connected');\n        return this._acquireClient(client, pendingItem, idleListener, true);\n      }\n    });\n  } // acquire a client for a pending work item\n\n\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client);\n    }\n\n    this.emit('acquire', client);\n    let released = false;\n\n    client.release = err => {\n      if (released) {\n        throwOnDoubleRelease();\n      }\n\n      released = true;\n\n      this._release(client, idleListener, err);\n    };\n\n    client.removeListener('error', idleListener);\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, err => {\n          if (err) {\n            client.release(err);\n            return pendingItem.callback(err, undefined, NOOP);\n          }\n\n          pendingItem.callback(undefined, client, client.release);\n        });\n      } else {\n        pendingItem.callback(undefined, client, client.release);\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release);\n      } else {\n        client.release();\n      }\n    }\n  } // release a client back to the poll, include an error\n  // to remove it from the pool\n\n\n  _release(client, idleListener, err) {\n    client.on('error', idleListener);\n    client._poolUseCount = (client._poolUseCount || 0) + 1; // TODO(bmc): expose a proper, public interface _queryable and _ending\n\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client');\n      }\n\n      this._remove(client);\n\n      this._pulseQueue();\n\n      return;\n    } // idle timeout\n\n\n    let tid;\n\n    if (this.options.idleTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('remove idle client');\n\n        this._remove(client);\n      }, this.options.idleTimeoutMillis);\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid));\n\n    this._pulseQueue();\n  }\n\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text);\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'));\n      });\n      return response.result;\n    } // allow plain text query without values\n\n\n    if (typeof values === 'function') {\n      cb = values;\n      values = undefined;\n    }\n\n    const response = promisify(this.Promise, cb);\n    cb = response.callback;\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err);\n      }\n\n      let clientReleased = false;\n\n      const onError = err => {\n        if (clientReleased) {\n          return;\n        }\n\n        clientReleased = true;\n        client.release(err);\n        cb(err);\n      };\n\n      client.once('error', onError);\n      this.log('dispatching query');\n      client.query(text, values, (err, res) => {\n        this.log('query dispatched');\n        client.removeListener('error', onError);\n\n        if (clientReleased) {\n          return;\n        }\n\n        clientReleased = true;\n        client.release(err);\n\n        if (err) {\n          return cb(err);\n        } else {\n          return cb(undefined, res);\n        }\n      });\n    });\n    return response.result;\n  }\n\n  end(cb) {\n    this.log('ending');\n\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once');\n      return cb ? cb(err) : this.Promise.reject(err);\n    }\n\n    this.ending = true;\n    const promised = promisify(this.Promise, cb);\n    this._endCallback = promised.callback;\n\n    this._pulseQueue();\n\n    return promised.result;\n  }\n\n  get waitingCount() {\n    return this._pendingQueue.length;\n  }\n\n  get idleCount() {\n    return this._idle.length;\n  }\n\n  get totalCount() {\n    return this._clients.length;\n  }\n\n}\n\nmodule.exports = Pool;","map":{"version":3,"sources":["C:/Users/User/Documents/GitHub/web-prototype/rocket/src/backend/node_modules/pg-pool/index.js"],"names":["EventEmitter","require","NOOP","removeWhere","list","predicate","i","findIndex","undefined","splice","IdleItem","constructor","client","idleListener","timeoutId","PendingItem","callback","throwOnDoubleRelease","Error","promisify","Promise","result","rej","res","cb","err","resolve","reject","makeIdleListener","pool","removeListener","on","log","_remove","emit","Pool","options","Client","Object","assign","defineProperty","configurable","enumerable","writable","value","password","max","poolSize","maxUses","Infinity","global","idleTimeoutMillis","_clients","_idle","_pendingQueue","_endCallback","ending","ended","_isFull","length","_pulseQueue","slice","map","item","pendingItem","shift","idleItem","pop","clearTimeout","_acquireClient","newClient","removed","filter","c","end","connect","response","process","nextTick","connectionTimeoutMillis","push","queueCallback","done","tid","setTimeout","timedOut","timeoutHit","connection","stream","destroy","message","isNew","released","release","_release","verify","_poolUseCount","_queryable","_ending","query","text","values","setImmediate","clientReleased","onError","once","promised","waitingCount","idleCount","totalCount","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst EventEmitter = require('events').EventEmitter\n\nconst NOOP = function () { }\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate)\n\n  return i === -1\n    ? undefined\n    : list.splice(i, 1)[0]\n}\n\nclass IdleItem {\n  constructor (client, idleListener, timeoutId) {\n    this.client = client\n    this.idleListener = idleListener\n    this.timeoutId = timeoutId\n  }\n}\n\nclass PendingItem {\n  constructor (callback) {\n    this.callback = callback\n  }\n}\n\nfunction throwOnDoubleRelease () {\n  throw new Error('Release called on client which has already been released to the pool.')\n}\n\nfunction promisify (Promise, callback) {\n  if (callback) {\n    return { callback: callback, result: undefined }\n  }\n  let rej\n  let res\n  const cb = function (err, client) {\n    err ? rej(err) : res(client)\n  }\n  const result = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  })\n  return { callback: cb, result: result }\n}\n\nfunction makeIdleListener (pool, client) {\n  return function idleListener (err) {\n    err.client = client\n\n    client.removeListener('error', idleListener)\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err)\n    })\n    pool._remove(client)\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client)\n  }\n}\n\nclass Pool extends EventEmitter {\n  constructor (options, Client) {\n    super()\n    this.options = Object.assign({}, options)\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password\n      })\n    }\n\n    this.options.max = this.options.max || this.options.poolSize || 10\n    this.options.maxUses = this.options.maxUses || Infinity\n    this.log = this.options.log || function () { }\n    this.Client = this.options.Client || Client || require('pg').Client\n    this.Promise = this.options.Promise || global.Promise\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000\n    }\n\n    this._clients = []\n    this._idle = []\n    this._pendingQueue = []\n    this._endCallback = undefined\n    this.ending = false\n    this.ended = false\n  }\n\n  _isFull () {\n    return this._clients.length >= this.options.max\n  }\n\n  _pulseQueue () {\n    this.log('pulse queue')\n    if (this.ended) {\n      this.log('pulse queue ended')\n      return\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending')\n      if (this._idle.length) {\n        this._idle.slice().map(item => {\n          this._remove(item.client)\n        })\n      }\n      if (!this._clients.length) {\n        this.ended = true\n        this._endCallback()\n      }\n      return\n    }\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests')\n      return\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return\n    }\n    const pendingItem = this._pendingQueue.shift()\n    if (this._idle.length) {\n      const idleItem = this._idle.pop()\n      clearTimeout(idleItem.timeoutId)\n      const client = idleItem.client\n      const idleListener = idleItem.idleListener\n\n      return this._acquireClient(client, pendingItem, idleListener, false)\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem)\n    }\n    throw new Error('unexpected condition')\n  }\n\n  _remove (client) {\n    const removed = removeWhere(\n      this._idle,\n      item => item.client === client\n    )\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId)\n    }\n\n    this._clients = this._clients.filter(c => c !== client)\n    client.end()\n    this.emit('remove', client)\n  }\n\n  connect (cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n\n    const response = promisify(this.Promise, cb)\n    const result = response.result\n\n    // if we don't have to connect a new client, don't do so\n    if (this._clients.length >= this.options.max || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue())\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback))\n        return result\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid)\n        response.callback(err, res, done)\n      }\n\n      const pendingItem = new PendingItem(queueCallback)\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)\n        pendingItem.timedOut = true\n        response.callback(new Error('timeout exceeded when trying to connect'))\n      }, this.options.connectionTimeoutMillis)\n\n      this._pendingQueue.push(pendingItem)\n      return result\n    }\n\n    this.newClient(new PendingItem(response.callback))\n\n    return result\n  }\n\n  newClient (pendingItem) {\n    const client = new this.Client(this.options)\n    this._clients.push(client)\n    const idleListener = makeIdleListener(this, client)\n\n    this.log('checking client timeout')\n\n    // connection timeout logic\n    let tid\n    let timeoutHit = false\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout')\n        timeoutHit = true\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end()\n      }, this.options.connectionTimeoutMillis)\n    }\n\n    this.log('connecting new client')\n    client.connect((err) => {\n      if (tid) {\n        clearTimeout(tid)\n      }\n      client.on('error', idleListener)\n      if (err) {\n        this.log('client failed to connect', err)\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter(c => c !== client)\n        if (timeoutHit) {\n          err.message = 'Connection terminated due to connection timeout'\n        }\n\n        // this client wonâ€™t be released, so move on immediately\n        this._pulseQueue()\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP)\n        }\n      } else {\n        this.log('new client connected')\n\n        return this._acquireClient(client, pendingItem, idleListener, true)\n      }\n    })\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient (client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client)\n    }\n\n    this.emit('acquire', client)\n\n    let released = false\n\n    client.release = (err) => {\n      if (released) {\n        throwOnDoubleRelease()\n      }\n\n      released = true\n      this._release(client, idleListener, err)\n    }\n\n    client.removeListener('error', idleListener)\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, (err) => {\n          if (err) {\n            client.release(err)\n            return pendingItem.callback(err, undefined, NOOP)\n          }\n\n          pendingItem.callback(undefined, client, client.release)\n        })\n      } else {\n        pendingItem.callback(undefined, client, client.release)\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release)\n      } else {\n        client.release()\n      }\n    }\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release (client, idleListener, err) {\n    client.on('error', idleListener)\n\n    client._poolUseCount = (client._poolUseCount || 0) + 1\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client')\n      }\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    // idle timeout\n    let tid\n    if (this.options.idleTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('remove idle client')\n        this._remove(client)\n      }, this.options.idleTimeoutMillis)\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid))\n    this._pulseQueue()\n  }\n\n  query (text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text)\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))\n      })\n      return response.result\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values\n      values = undefined\n    }\n    const response = promisify(this.Promise, cb)\n    cb = response.callback\n\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err)\n      }\n\n      let clientReleased = false\n      const onError = (err) => {\n        if (clientReleased) {\n          return\n        }\n        clientReleased = true\n        client.release(err)\n        cb(err)\n      }\n\n      client.once('error', onError)\n      this.log('dispatching query')\n      client.query(text, values, (err, res) => {\n        this.log('query dispatched')\n        client.removeListener('error', onError)\n        if (clientReleased) {\n          return\n        }\n        clientReleased = true\n        client.release(err)\n        if (err) {\n          return cb(err)\n        } else {\n          return cb(undefined, res)\n        }\n      })\n    })\n    return response.result\n  }\n\n  end (cb) {\n    this.log('ending')\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n    this.ending = true\n    const promised = promisify(this.Promise, cb)\n    this._endCallback = promised.callback\n    this._pulseQueue()\n    return promised.result\n  }\n\n  get waitingCount () {\n    return this._pendingQueue.length\n  }\n\n  get idleCount () {\n    return this._idle.length\n  }\n\n  get totalCount () {\n    return this._clients.length\n  }\n}\nmodule.exports = Pool\n"]},"metadata":{},"sourceType":"module"}